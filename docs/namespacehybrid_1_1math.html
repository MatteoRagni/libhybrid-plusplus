<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libhybrid++: hybrid::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libhybrid++
   </div>
   <div id="projectbrief">A library for discretized Hybrid Dynamical Systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehybrid.html">hybrid</a></li><li class="navelem"><a class="el" href="namespacehybrid_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">hybrid::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehybrid_1_1math_1_1wrapper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math_1_1wrapper.html">wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Math utilities</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa09cb6afc377fe61dc0795ca2ecbf971"></a>This namespcae contains some of the math utilities that are used internally in libhybridpp. In particular, integrators make use of sum, LU decomposition and other linear algebra utilities that leverage the Lapack and Blas. </p>
</td></tr>
<tr class="memitem:a93f47d24fcfca2b55b27be1b31c37782"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t rows, std::size_t cols&gt; </td></tr>
<tr class="memitem:a93f47d24fcfca2b55b27be1b31c37782"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a93f47d24fcfca2b55b27be1b31c37782">b_array_t</a> = std::array&lt; REAL_T, <a class="el" href="structhybrid_1_1utility_1_1biggest__dim.html">hybrid::utility::biggest_dim</a>&lt; rows, cols &gt;::value &gt;</td></tr>
<tr class="memdesc:a93f47d24fcfca2b55b27be1b31c37782"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Internal</b> Input type for solver SFINAE type deduction  <a href="#a93f47d24fcfca2b55b27be1b31c37782">More...</a><br /></td></tr>
<tr class="separator:a93f47d24fcfca2b55b27be1b31c37782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0261c588eae54d2b55f56ac26cb3ed"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t dim&gt; </td></tr>
<tr class="memitem:abe0261c588eae54d2b55f56ac26cb3ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#abe0261c588eae54d2b55f56ac26cb3ed">sum</a> (std::array&lt; REAL_T, dim &gt; &amp;out, const std::array&lt; REAL_T, dim &gt; &amp;in, const REAL_T <a class="el" href="namespacehybrid_1_1math.html#a3e070bf12063dca21d6705f58c9d1865">scale</a>)</td></tr>
<tr class="memdesc:abe0261c588eae54d2b55f56ac26cb3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and sum two arrays.  <a href="#abe0261c588eae54d2b55f56ac26cb3ed">More...</a><br /></td></tr>
<tr class="separator:abe0261c588eae54d2b55f56ac26cb3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7045e5769c6ca2a472008461564c7cd"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t dim&gt; </td></tr>
<tr class="memitem:ac7045e5769c6ca2a472008461564c7cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#ac7045e5769c6ca2a472008461564c7cd">sum</a> (std::array&lt; REAL_T, dim &gt; &amp;out, const std::array&lt; REAL_T, dim &gt; &amp;in)</td></tr>
<tr class="memdesc:ac7045e5769c6ca2a472008461564c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two arrays.  <a href="#ac7045e5769c6ca2a472008461564c7cd">More...</a><br /></td></tr>
<tr class="separator:ac7045e5769c6ca2a472008461564c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e070bf12063dca21d6705f58c9d1865"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t dim&gt; </td></tr>
<tr class="memitem:a3e070bf12063dca21d6705f58c9d1865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a3e070bf12063dca21d6705f58c9d1865">scale</a> (std::array&lt; REAL_T, dim &gt; &amp;out, REAL_T s)</td></tr>
<tr class="memdesc:a3e070bf12063dca21d6705f58c9d1865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale an array.  <a href="#a3e070bf12063dca21d6705f58c9d1865">More...</a><br /></td></tr>
<tr class="separator:a3e070bf12063dca21d6705f58c9d1865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db0dd88684bf04e04fe969663d6d5d"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t dim&gt; </td></tr>
<tr class="memitem:ab3db0dd88684bf04e04fe969663d6d5d"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#ab3db0dd88684bf04e04fe969663d6d5d">norm</a> (const std::array&lt; REAL_T, dim &gt; &amp;in)</td></tr>
<tr class="memdesc:ab3db0dd88684bf04e04fe969663d6d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of an array.  <a href="#ab3db0dd88684bf04e04fe969663d6d5d">More...</a><br /></td></tr>
<tr class="separator:ab3db0dd88684bf04e04fe969663d6d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb52215d6f60cc84f308e10573dfef9"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t rows, std::size_t cols&gt; </td></tr>
<tr class="memitem:acdb52215d6f60cc84f308e10573dfef9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#acdb52215d6f60cc84f308e10573dfef9">solve</a> (std::array&lt; REAL_T, cols *rows &gt; &amp;A, <a class="el" href="namespacehybrid_1_1math.html#a93f47d24fcfca2b55b27be1b31c37782">b_array_t</a>&lt; REAL_T, cols, rows &gt; &amp;b)</td></tr>
<tr class="memdesc:acdb52215d6f60cc84f308e10573dfef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves overdetermined linear systems.  <a href="#acdb52215d6f60cc84f308e10573dfef9">More...</a><br /></td></tr>
<tr class="separator:acdb52215d6f60cc84f308e10573dfef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8761540f78d5c31e2450532d36c04a49"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:a8761540f78d5c31e2450532d36c04a49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a8761540f78d5c31e2450532d36c04a49">copy</a> (std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</td></tr>
<tr class="memdesc:a8761540f78d5c31e2450532d36c04a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a source array in a destination.  <a href="#a8761540f78d5c31e2450532d36c04a49">More...</a><br /></td></tr>
<tr class="separator:a8761540f78d5c31e2450532d36c04a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4b77ee3da08e957cd0dd2ac1947ce"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:a43b4b77ee3da08e957cd0dd2ac1947ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a43b4b77ee3da08e957cd0dd2ac1947ce">element_prod</a> (std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;source)</td></tr>
<tr class="memdesc:a43b4b77ee3da08e957cd0dd2ac1947ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise product between two array.  <a href="#a43b4b77ee3da08e957cd0dd2ac1947ce">More...</a><br /></td></tr>
<tr class="separator:a43b4b77ee3da08e957cd0dd2ac1947ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0d60b5c9949c01d8e1b126a023936f"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:a0f0d60b5c9949c01d8e1b126a023936f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a0f0d60b5c9949c01d8e1b126a023936f">element_div</a> (std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;source)</td></tr>
<tr class="memdesc:a0f0d60b5c9949c01d8e1b126a023936f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division between two array.  <a href="#a0f0d60b5c9949c01d8e1b126a023936f">More...</a><br /></td></tr>
<tr class="separator:a0f0d60b5c9949c01d8e1b126a023936f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687fe2363948b64adbf015073ef03d66"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:a687fe2363948b64adbf015073ef03d66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a687fe2363948b64adbf015073ef03d66">element_compare</a> (const std::array&lt; REAL_T, n &gt; &amp;a, const std::array&lt; REAL_T, n &gt; &amp;b)</td></tr>
<tr class="memdesc:a687fe2363948b64adbf015073ef03d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectors comparison Makes the elementwise comparison between two vectors \( a &gt;= b\). It is true if all are true.  <a href="#a687fe2363948b64adbf015073ef03d66">More...</a><br /></td></tr>
<tr class="separator:a687fe2363948b64adbf015073ef03d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82f7e00abec371bf9fd8cc5740b91f3"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:af82f7e00abec371bf9fd8cc5740b91f3"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#af82f7e00abec371bf9fd8cc5740b91f3">sign</a> (REAL_T a)</td></tr>
<tr class="memdesc:af82f7e00abec371bf9fd8cc5740b91f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the sign of a number.  <a href="#af82f7e00abec371bf9fd8cc5740b91f3">More...</a><br /></td></tr>
<tr class="separator:af82f7e00abec371bf9fd8cc5740b91f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699fc5dec73f14942d3d4d6295a5b554"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:a699fc5dec73f14942d3d4d6295a5b554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a699fc5dec73f14942d3d4d6295a5b554">sign</a> (std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</td></tr>
<tr class="memdesc:a699fc5dec73f14942d3d4d6295a5b554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the sign of an array elementwise.  <a href="#a699fc5dec73f14942d3d4d6295a5b554">More...</a><br /></td></tr>
<tr class="separator:a699fc5dec73f14942d3d4d6295a5b554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3b3d7626f52e77e22fbb7a02bdc13b"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:a1a3b3d7626f52e77e22fbb7a02bdc13b"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a1a3b3d7626f52e77e22fbb7a02bdc13b">abs</a> (REAL_T a)</td></tr>
<tr class="memdesc:a1a3b3d7626f52e77e22fbb7a02bdc13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the absolute value of a number.  <a href="#a1a3b3d7626f52e77e22fbb7a02bdc13b">More...</a><br /></td></tr>
<tr class="separator:a1a3b3d7626f52e77e22fbb7a02bdc13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4aef43b9ea2a2bbdd01c3165690a70"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T , std::size_t n&gt; </td></tr>
<tr class="memitem:abb4aef43b9ea2a2bbdd01c3165690a70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#abb4aef43b9ea2a2bbdd01c3165690a70">abs</a> (std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</td></tr>
<tr class="memdesc:abb4aef43b9ea2a2bbdd01c3165690a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the absolute value of an array elementwise.  <a href="#abb4aef43b9ea2a2bbdd01c3165690a70">More...</a><br /></td></tr>
<tr class="separator:abb4aef43b9ea2a2bbdd01c3165690a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87d7e25de4799a1a7a9e3737d4c419"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:a2f87d7e25de4799a1a7a9e3737d4c419"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a2f87d7e25de4799a1a7a9e3737d4c419">signsqrt</a> (REAL_T x)</td></tr>
<tr class="memdesc:a2f87d7e25de4799a1a7a9e3737d4c419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signed squared root of a number.  <a href="#a2f87d7e25de4799a1a7a9e3737d4c419">More...</a><br /></td></tr>
<tr class="separator:a2f87d7e25de4799a1a7a9e3737d4c419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f093187891838e39b3509c209a68dd7"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:a9f093187891838e39b3509c209a68dd7"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a9f093187891838e39b3509c209a68dd7">signsqrt</a> (REAL_T a, REAL_T b)</td></tr>
<tr class="memdesc:a9f093187891838e39b3509c209a68dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signed squared root of the difference of two numbers.  <a href="#a9f093187891838e39b3509c209a68dd7">More...</a><br /></td></tr>
<tr class="separator:a9f093187891838e39b3509c209a68dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae407fbfa63f77b3037b38ff7841255f3"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:ae407fbfa63f77b3037b38ff7841255f3"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#ae407fbfa63f77b3037b38ff7841255f3">min</a> (REAL_T a, REAL_T b)</td></tr>
<tr class="memdesc:ae407fbfa63f77b3037b38ff7841255f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum between two real number.  <a href="#ae407fbfa63f77b3037b38ff7841255f3">More...</a><br /></td></tr>
<tr class="separator:ae407fbfa63f77b3037b38ff7841255f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2443f8955d893d9a70bd501fd1e423db"><td class="memTemplParams" colspan="2">template&lt;typename REAL_T &gt; </td></tr>
<tr class="memitem:a2443f8955d893d9a70bd501fd1e423db"><td class="memTemplItemLeft" align="right" valign="top">REAL_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehybrid_1_1math.html#a2443f8955d893d9a70bd501fd1e423db">max</a> (REAL_T a, REAL_T b)</td></tr>
<tr class="memdesc:a2443f8955d893d9a70bd501fd1e423db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum between two real number.  <a href="#a2443f8955d893d9a70bd501fd1e423db">More...</a><br /></td></tr>
<tr class="separator:a2443f8955d893d9a70bd501fd1e423db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a93f47d24fcfca2b55b27be1b31c37782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f47d24fcfca2b55b27be1b31c37782">&#9670;&nbsp;</a></span>b_array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t rows, std::size_t cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehybrid_1_1math.html#a93f47d24fcfca2b55b27be1b31c37782">hybrid::math::b_array_t</a> = typedef std::array&lt; REAL_T, <a class="el" href="structhybrid_1_1utility_1_1biggest__dim.html">hybrid::utility::biggest_dim</a>&lt; rows, cols &gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Internal</b> Input type for solver SFINAE type deduction </p>
<p>This internal type make transparent for the user the static selection of the solver to use in case of overdetermined or undermined system of equations. To solve the the linear equations, since the vector \( b \) is also the vector that will contain the result of the operation, it is required that it has dimensions \( \max(rows(A), cols(A)) \). This type ensures that. </p>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00425">425</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1a3b3d7626f52e77e22fbb7a02bdc13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3b3d7626f52e77e22fbb7a02bdc13b">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::abs </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the absolute value of a number. </p>
<p>Evluates the absolute value of a number </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the number on which we want to evaluate the absolute value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>a</code> if the number is positive, <code>-a</code> if the number is negative </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00552">552</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                         {</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;      <span class="keywordflow">return</span> a * <a class="code" href="namespacehybrid_1_1math.html#af82f7e00abec371bf9fd8cc5740b91f3">hybrid::math::sign</a>(a);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_af82f7e00abec371bf9fd8cc5740b91f3"><div class="ttname"><a href="namespacehybrid_1_1math.html#af82f7e00abec371bf9fd8cc5740b91f3">hybrid::math::sign</a></div><div class="ttdeci">REAL_T sign(REAL_T a)</div><div class="ttdoc">Evaluates the sign of a number. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00522">math.hpp:522</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb4aef43b9ea2a2bbdd01c3165690a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4aef43b9ea2a2bbdd01c3165690a70">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::abs </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the absolute value of an array elementwise. </p>
<p>Evluates the absolute value of each entry of an array of number, </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the array on which we will save the result </td></tr>
    <tr><td class="paramname">src</td><td>the array on which we want to evaluate the sign </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00566">566</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                                                                            {</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; i++)</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        dest[i] = <a class="code" href="namespacehybrid_1_1math.html#a1a3b3d7626f52e77e22fbb7a02bdc13b">hybrid::math::abs</a>(src[i]);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a1a3b3d7626f52e77e22fbb7a02bdc13b"><div class="ttname"><a href="namespacehybrid_1_1math.html#a1a3b3d7626f52e77e22fbb7a02bdc13b">hybrid::math::abs</a></div><div class="ttdeci">REAL_T abs(REAL_T a)</div><div class="ttdoc">Evaluates the absolute value of a number. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00552">math.hpp:552</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8761540f78d5c31e2450532d36c04a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8761540f78d5c31e2450532d36c04a49">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::copy </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a source array in a destination. </p>
<p>Copy for a source array in a destination</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>dimensions for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination array </td></tr>
    <tr><td class="paramname">src</td><td>source array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00464">464</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                                                                             {</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;      <a class="code" href="namespacehybrid_1_1math.html#a8761540f78d5c31e2450532d36c04a49">std::copy</a>(std::begin(src), std::end(src), std::begin(dest));</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a8761540f78d5c31e2450532d36c04a49"><div class="ttname"><a href="namespacehybrid_1_1math.html#a8761540f78d5c31e2450532d36c04a49">hybrid::math::copy</a></div><div class="ttdeci">void copy(std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</div><div class="ttdoc">Copy a source array in a destination. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00464">math.hpp:464</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a687fe2363948b64adbf015073ef03d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687fe2363948b64adbf015073ef03d66">&#9670;&nbsp;</a></span>element_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hybrid::math::element_compare </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectors comparison Makes the elementwise comparison between two vectors \( a &gt;= b\). It is true if all are true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>dimensions for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first of the two arrays for comparison </td></tr>
    <tr><td class="paramname">b</td><td>second of the two arrays for comparison </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00505">505</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                                                                                         {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;      <span class="keywordtype">bool</span> ret = <span class="keyword">true</span>;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; i++) {</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        ret = ret &amp;&amp; (a[i] &gt;= b[i]);</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      }</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a0f0d60b5c9949c01d8e1b126a023936f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0d60b5c9949c01d8e1b126a023936f">&#9670;&nbsp;</a></span>element_div()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::element_div </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise division between two array. </p>
<p>Makes the pointwise division between two array </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>dimensions for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination array </td></tr>
    <tr><td class="paramname">source</td><td>source array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00491">491</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                                                                                       {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; i++)</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        dest[i] = dest[i] / source[i];</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a43b4b77ee3da08e957cd0dd2ac1947ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b4b77ee3da08e957cd0dd2ac1947ce">&#9670;&nbsp;</a></span>element_prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::element_prod </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise product between two array. </p>
<p>Makes the pointwise product between two array </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>dimensions for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination array </td></tr>
    <tr><td class="paramname">source</td><td>source array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00477">477</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                                                                                        {</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; i++)</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        dest[i] *= source[i];</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a2443f8955d893d9a70bd501fd1e423db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2443f8955d893d9a70bd501fd1e423db">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::max </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum between two real number. </p>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00613">613</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                                   {</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;      <span class="keywordflow">return</span> a &gt;= b ? a : b;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ae407fbfa63f77b3037b38ff7841255f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae407fbfa63f77b3037b38ff7841255f3">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::min </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum between two real number. </p>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00606">606</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                                   {</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      <span class="keywordflow">return</span> a &gt;= b ? b : a;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ab3db0dd88684bf04e04fe969663d6d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3db0dd88684bf04e04fe969663d6d5d">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::norm </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the norm of an array. </p>
<p>The function performs the following operation: </p><p class="formulaDsp">
\[ \gamma \leftarrow || x ||_{2}, \qquad x \in \mathbb{R}^{\dim}, \, \gamma \in \mathbb{R} \]
</p>
<p> where \(x\) is a vector of size <code>dim</code>, and \(\alpha\) is a scalar that contains the norm of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>a floating point value (inheriting from <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">dim</td><td>size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the \(x\) vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scale the norm scalar \(\gamma\) </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00404">404</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                                                   {</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::NORM] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="preprocessor">#ifndef MATLAB_MEX_FILE</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      <span class="keywordflow">return</span> wrapper::norm&lt; dim &gt;(in);</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;      REAL_T r = 0.0;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x : in)</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        r += (x * x);</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      <span class="keywordflow">return</span> sqrt(r);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a3e070bf12063dca21d6705f58c9d1865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e070bf12063dca21d6705f58c9d1865">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::scale </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale an array. </p>
<p>The function performs the following operation: </p><p class="formulaDsp">
\[ x \leftarrow \alpha x, \qquad x \in \mathbb{R}^{\dim}, \, \alpha \in \mathbb{R} \]
</p>
<p> where \(x\) is a vector of size <code>dim</code>, and \(\alpha\) is a scalar value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>a floating point value (inheriting from <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">dim</td><td>size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the \(x\) vector. It will also contain the output vector </td></tr>
    <tr><td class="paramname">s</td><td>the scaling factor \(\alpha\) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00380">380</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                                                       {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SCALE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="preprocessor">#ifndef MATLAB_MEX_FILE</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      wrapper::scale&lt; dim &gt;(out, s);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;x : out)</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        x *= s;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="af82f7e00abec371bf9fd8cc5740b91f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82f7e00abec371bf9fd8cc5740b91f3">&#9670;&nbsp;</a></span>sign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::sign </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the sign of a number. </p>
<p>Evluates the sign of a number, returning +1 if it is positive and -1 if it is negative \(a = 0\) is considered as positive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the number on which we want to evaluate the sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>+1 is <code>a</code> is positive, -1 if it is negative </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00522">522</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                          {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;      <span class="keywordflow">return</span> a &gt;= 0 ? 1 : -1;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a699fc5dec73f14942d3d4d6295a5b554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699fc5dec73f14942d3d4d6295a5b554">&#9670;&nbsp;</a></span>sign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::sign </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the sign of an array elementwise. </p>
<p>Evluates the sign of each entry of an array number, returning +1 if it is positive and -1 if it is negative. A null entry is considered as positive. for each position. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>floating point precision </td></tr>
    <tr><td class="paramname">n</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the array on which we will save the result </td></tr>
    <tr><td class="paramname">src</td><td>the array on which we want to evaluate the sign </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00538">538</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                                                                             {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; i++)</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        dest[i] = <a class="code" href="namespacehybrid_1_1math.html#a699fc5dec73f14942d3d4d6295a5b554">sign</a>(src[i]);</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a699fc5dec73f14942d3d4d6295a5b554"><div class="ttname"><a href="namespacehybrid_1_1math.html#a699fc5dec73f14942d3d4d6295a5b554">hybrid::math::sign</a></div><div class="ttdeci">void sign(std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</div><div class="ttdoc">Evaluates the sign of an array elementwise. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00538">math.hpp:538</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f87d7e25de4799a1a7a9e3737d4c419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f87d7e25de4799a1a7a9e3737d4c419">&#9670;&nbsp;</a></span>signsqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::signsqrt </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the signed squared root of a number. </p>
<p>The function evaluates: </p><p class="formulaDsp">
\[ r = \mathrm{sign}(x) \sqrt{|x|} \]
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>type for the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the argument for the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the above operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00583">583</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                              {</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacehybrid_1_1math.html#a699fc5dec73f14942d3d4d6295a5b554">sign</a>(x) * sqrt(<a class="code" href="namespacehybrid_1_1math.html#a1a3b3d7626f52e77e22fbb7a02bdc13b">hybrid::math::abs</a>(x));</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a1a3b3d7626f52e77e22fbb7a02bdc13b"><div class="ttname"><a href="namespacehybrid_1_1math.html#a1a3b3d7626f52e77e22fbb7a02bdc13b">hybrid::math::abs</a></div><div class="ttdeci">REAL_T abs(REAL_T a)</div><div class="ttdoc">Evaluates the absolute value of a number. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00552">math.hpp:552</a></div></div>
<div class="ttc" id="namespacehybrid_1_1math_html_a699fc5dec73f14942d3d4d6295a5b554"><div class="ttname"><a href="namespacehybrid_1_1math.html#a699fc5dec73f14942d3d4d6295a5b554">hybrid::math::sign</a></div><div class="ttdeci">void sign(std::array&lt; REAL_T, n &gt; &amp;dest, const std::array&lt; REAL_T, n &gt; &amp;src)</div><div class="ttdoc">Evaluates the sign of an array elementwise. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00538">math.hpp:538</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f093187891838e39b3509c209a68dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f093187891838e39b3509c209a68dd7">&#9670;&nbsp;</a></span>signsqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">REAL_T hybrid::math::signsqrt </td>
          <td>(</td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL_T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the signed squared root of the difference of two numbers. </p>
<p>The function evaluates: </p><p class="formulaDsp">
\[ r = \mathrm{sign}(a - b) \sqrt{|a - b|} \]
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>type for the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first argument for the function </td></tr>
    <tr><td class="paramname">b</td><td>the second argument for the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the above operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00600">600</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                                        {</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacehybrid_1_1math.html#a2f87d7e25de4799a1a7a9e3737d4c419">hybrid::math::signsqrt</a>(a - b);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a2f87d7e25de4799a1a7a9e3737d4c419"><div class="ttname"><a href="namespacehybrid_1_1math.html#a2f87d7e25de4799a1a7a9e3737d4c419">hybrid::math::signsqrt</a></div><div class="ttdeci">REAL_T signsqrt(REAL_T x)</div><div class="ttdoc">Returns the signed squared root of a number. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00583">math.hpp:583</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acdb52215d6f60cc84f308e10573dfef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb52215d6f60cc84f308e10573dfef9">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t rows, std::size_t cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::solve </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, cols *rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehybrid_1_1math.html#a93f47d24fcfca2b55b27be1b31c37782">b_array_t</a>&lt; REAL_T, cols, rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves overdetermined linear systems. </p>
<p>This wrapper is used to solve (overdetermined) linear system. Given a linear system in the form: </p><p class="formulaDsp">
\[ A x + b = 0, \qquad A \in \mathbb{R}^{r \times c}, x \in \mathbb{R}^{c}, b \in \mathbb{R}^{r} \]
</p>
<p> the function evaluates \(x = -A^{\dagger} b\) for \(r \geq c\), that is equal to \(x = -A^{-1} b\) iff \(r = c\). The function evaluates \(x = \min_{x} || Ax + b ||_2 \) iff \( r \leq c \) The solution is stored in the vector \(b\), while the matrix \(A\) will contains the factorization. This is the reason why the memory available for \(b\) must be equal or greater of the memory needed for storing \(x\). The matrix \(A\) should be stored in memory with <b>row major ordering</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>a floating point value (inheriting from <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of matrix \(A\) </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns of matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix \(A\). Will contain the factorization as output </td></tr>
    <tr><td class="paramname">b</td><td>the vector \(b\). Will contain the result as output </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hybrid::wrapper::IllegalMatrix</td><td>if the matrix contains an illegal value </td></tr>
    <tr><td class="paramname">hybrid::wrapper::SingularMatrix</td><td>if the matrix is singular </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00449">449</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                                                                                       {</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SOLVE] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      wrapper::solve&lt; rows, cols, hybrid::utility::biggest_dim&lt; rows, cols &gt;::value &gt;(A, b);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="abe0261c588eae54d2b55f56ac26cb3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0261c588eae54d2b55f56ac26cb3ed">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::sum </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL_T&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale and sum two arrays. </p>
<p>The function performs the following operation: </p><p class="formulaDsp">
\[ x \leftarrow \alpha x + y, \qquad x, y \in \mathbb{R}^{\dim}, \, \alpha \in \mathbb{R} \]
</p>
<p> where \(x,y\) are two vectors of size <code>dim</code>, and \(\alpha\) is a scalar value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>a floating point value (inheriting from <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">dim</td><td>size of the vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the \(x\) vector. It will also contain the output vector </td></tr>
    <tr><td class="paramname">in</td><td>the \(y\) vector </td></tr>
    <tr><td class="paramname">scale</td><td>the scaling factor \(\alpha\) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00337">337</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                                                                                  {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SUM] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="preprocessor">#ifndef MATLAB_MEX_FILE</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;      wrapper::sum&lt; dim &gt;(out, in, <a class="code" href="namespacehybrid_1_1math.html#a3e070bf12063dca21d6705f58c9d1865">scale</a>);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; dim; i++)</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        out[i] = out[i] + <a class="code" href="namespacehybrid_1_1math.html#a3e070bf12063dca21d6705f58c9d1865">scale</a> * in[i];</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    }</div><div class="ttc" id="namespacehybrid_1_1math_html_a3e070bf12063dca21d6705f58c9d1865"><div class="ttname"><a href="namespacehybrid_1_1math.html#a3e070bf12063dca21d6705f58c9d1865">hybrid::math::scale</a></div><div class="ttdeci">void scale(std::array&lt; REAL_T, dim &gt; &amp;out, REAL_T s)</div><div class="ttdoc">Scale an array. </div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00380">math.hpp:380</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7045e5769c6ca2a472008461564c7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7045e5769c6ca2a472008461564c7cd">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REAL_T , std::size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hybrid::math::sum </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; REAL_T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum two arrays. </p>
<p>The function performs the following operation: </p><p class="formulaDsp">
\[ x \leftarrow x + y, \qquad x, y \in \mathbb{R}^{\dim} \]
</p>
<p> where \(x,y\) are two vectors of size <code>dim</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REAL_T</td><td>a floating point value (inheriting from <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">dim</td><td>size of the vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the \(x\) vector. It will also contain the output vector </td></tr>
    <tr><td class="paramname">in</td><td>the \(y\) vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="math_8hpp_source.html#l00361">361</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                                                                              {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      static_assert(std::is_floating_point&lt; REAL_T &gt;::value, <span class="stringliteral">&quot;[HYBRID::MATH::SUM] Only float/double accepted&quot;</span>);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      wrapper::sum&lt; dim &gt;(out, in, <span class="keyword">static_cast&lt;</span> REAL_T <span class="keyword">&gt;</span>(1.0));</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
